---
{"dg-publish":true,"permalink":"/02-进阶/14-高级技术/","dgPassFrontmatter":true}
---


## 1. 单元测试


单元测试，是对最小的功能单元，编写代码，进行测试，确保功能没有 bug。

IDEA 已经集成了单元测试框架 Junit 。无序自己导入 jar 包。

使用例子
```java

```


### 1.1. 单元测试断言

断言，用来检查程序的结果和自己的预期是否一致。

Assert.assertEquals
```java

```

### 1.2. Junit 常用注解

Junit 4 到 5 部分注解改了名字，功能不变。

| Junit 4 注解 | Junit 5 注解 | 作用                                               |
| ------------ | ------------ | -------------------------------------------------- |
| @Test        | @Test        | 修饰要测试的方法                                   |
| @Before      | @BeforeEach  | 修饰实例方法，在每个测试方之前执行一次 |
| @After       | @AfterEach   | 修饰实例方法，在每个测试方之后执行一次 |
| @BeforeClass | @BeforeAll   | 修饰静态方法，在所有测试方之前执行一次 |
| @AfterClass  | @AfterAll    | 修饰静态方法，在所有测试方之后执行一次 |


## 2. 反射

做/学习框架，会用到。

### 2.1. 是啥 ？

反射是指，加载类的字节码到内存，用编程的方式，获取类的信息（各成分）。

### 2.2. 步骤 ？

万物皆对象。先用反射获取类的信息（各成分）、在操作这些信息（各成分）。

- 加载类，获取类的字节码，Class 对象, 3 种方法
- 获取类的构造器，Constructor 对象, 创建对象。
- 获取类的成员变量，Field 对象
- 获取类的成员方法，Method 对象

Demo

```java
getConstructors  
getConstructor
getDeclaredConstructors  // Declared，表示拿到所有的，方法名不包含这个次，就只能获取 public 修饰的
getDeclaredConstructor
setAccessible(true)  禁止访问权限检查
c.newInstance()
c.newInstance("值")

getFields
getField
getDeclaredFields
getDeclaredField
f.getName
f.getType
f.setAccessible(true)
f.set(obj,"值")
f.get(obj)

methods同上
...

m.getName()
m.getParameterCount()
m.getReturnType()
m.setAccessible(true)
m.invoke(obj)
m.invoke(obj,"值")

class.getSimpleName()

```


### 2.3. Demo

把对象的字段和值保存到文件

```java

```

## 3. 注解

做/学习框架，会用到。

### 3.1. 注解

是什么
@开头的单词，注解给程序提供信息，决定程序的执行。

怎么用
```java
public @interface 名字 {
    public 数据类型 属性名() default 默认值;
}

// 只用一个属性value，或者同时存在其他都有默认值的属性，可以用@注解名("具体值") 给value属性赋值

```


**注解**的本质是**接口**

**注解的属性**本质是**接口中的抽象方法**


什么时候用


### 3.2. 元注解

特殊的注解

元注解是修饰注解的注解。

```java
@Retetion //保留 保留策略 自己写的代码常用保留到运行时
@Target //目标 元素类型
```


### 3.3. 解析注解 

通过反射解析注解

- isAnnotationPresent 判断当前对象上是否存在指定注解
- getDeclaredAnnotation 获取当前对象上的指定注解
- getDeclaredAnnotations 获取当前对象上的所有注解 

### 3.4. 例子

```java
获取注解的信息

```

### 3.5. 模拟实现 Junit 的@Test

```

```

## 4. 动态代理

### 4.1. 什么时候用代理？

对象自己做的事情太多，可以通过代理，转移部分工作。

对象的方法要被代理，代理者（接口）就一定要有对应的方法（接口中的抽象方法）。


```java

```

### 4.2. 生成动态代理对象？

Proxy 类, Java 提供的创建代理对象的类。
Proxy. newProxyInstance (loader, interfaces, h)


```java

```

### 4.3. Demo

方法耗时

重复代码的优化，用代理。

```java

```
